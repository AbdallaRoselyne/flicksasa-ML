{"filter":false,"title":"content .py","tooltip":"/content .py","undoManager":{"mark":27,"position":27,"stack":[[{"start":{"row":0,"column":0},"end":{"row":62,"column":0},"action":"insert","lines":["import pandas as pd","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Load the data","movies_df = pd.read_csv('imdb/combined_processed.csv')","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'The Bone Collector'","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""],"id":57}],[{"start":{"row":5,"column":23},"end":{"row":5,"column":53},"action":"remove","lines":["('imdb/combined_processed.csv'"],"id":58},{"start":{"row":5,"column":23},"end":{"row":5,"column":52},"action":"insert","lines":["'imdb/combined_processed.csv'"]}],[{"start":{"row":5,"column":23},"end":{"row":5,"column":24},"action":"insert","lines":["("],"id":59}],[{"start":{"row":0,"column":0},"end":{"row":62,"column":0},"action":"remove","lines":["import pandas as pd","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Load the data","movies_df = pd.read_csv('imdb/combined_processed.csv')","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'The Bone Collector'","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""],"id":60},{"start":{"row":0,"column":0},"end":{"row":75,"column":0},"action":"insert","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client","s3 = boto3.client('s3')","","# S3 bucket and file details","bucket_name = 'Flicksasa'","file_key = 'imdb/combined_processed.csv'","","# Fetch the file from S3","obj = s3.get_object(Bucket=bucket_name, Key=file_key)","data = obj['Body'].read().decode('utf-8')","","# Load the data into a DataFrame","movies_df = pd.read_csv(StringIO(data))","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'The Bone Collector'","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""]}],[{"start":{"row":10,"column":14},"end":{"row":10,"column":25},"action":"remove","lines":["'Flicksasa'"],"id":61},{"start":{"row":10,"column":14},"end":{"row":10,"column":27},"action":"insert","lines":["'myflicksasa'"]}],[{"start":{"row":68,"column":40},"end":{"row":68,"column":41},"action":"remove","lines":["r"],"id":62},{"start":{"row":68,"column":39},"end":{"row":68,"column":40},"action":"remove","lines":["o"]},{"start":{"row":68,"column":38},"end":{"row":68,"column":39},"action":"remove","lines":["t"]},{"start":{"row":68,"column":37},"end":{"row":68,"column":38},"action":"remove","lines":["c"]},{"start":{"row":68,"column":36},"end":{"row":68,"column":37},"action":"remove","lines":["e"]},{"start":{"row":68,"column":35},"end":{"row":68,"column":36},"action":"remove","lines":["l"]},{"start":{"row":68,"column":34},"end":{"row":68,"column":35},"action":"remove","lines":["l"]},{"start":{"row":68,"column":33},"end":{"row":68,"column":34},"action":"remove","lines":["o"]},{"start":{"row":68,"column":32},"end":{"row":68,"column":33},"action":"remove","lines":["C"]},{"start":{"row":68,"column":31},"end":{"row":68,"column":32},"action":"remove","lines":[" "]}],[{"start":{"row":68,"column":30},"end":{"row":68,"column":31},"action":"remove","lines":["e"],"id":63},{"start":{"row":68,"column":29},"end":{"row":68,"column":30},"action":"remove","lines":["n"]},{"start":{"row":68,"column":28},"end":{"row":68,"column":29},"action":"remove","lines":["o"]}],[{"start":{"row":68,"column":28},"end":{"row":68,"column":29},"action":"insert","lines":["o"],"id":64},{"start":{"row":68,"column":29},"end":{"row":68,"column":30},"action":"insert","lines":["y"]},{"start":{"row":68,"column":30},"end":{"row":68,"column":31},"action":"insert","lines":["s"]}],[{"start":{"row":68,"column":23},"end":{"row":68,"column":31},"action":"remove","lines":["The Boys"],"id":65},{"start":{"row":68,"column":23},"end":{"row":68,"column":31},"action":"insert","lines":["The Boys"]}],[{"start":{"row":68,"column":23},"end":{"row":68,"column":24},"action":"insert","lines":["2"],"id":66},{"start":{"row":68,"column":24},"end":{"row":68,"column":25},"action":"insert","lines":["."]}],[{"start":{"row":68,"column":25},"end":{"row":68,"column":26},"action":"insert","lines":[" "],"id":67}],[{"start":{"row":68,"column":25},"end":{"row":68,"column":26},"action":"remove","lines":[" "],"id":68}],[{"start":{"row":68,"column":24},"end":{"row":68,"column":25},"action":"remove","lines":["."],"id":69},{"start":{"row":68,"column":23},"end":{"row":68,"column":24},"action":"remove","lines":["2"]}],[{"start":{"row":68,"column":23},"end":{"row":68,"column":24},"action":"insert","lines":["I"],"id":70},{"start":{"row":68,"column":24},"end":{"row":68,"column":25},"action":"insert","lines":["F"]}],[{"start":{"row":68,"column":32},"end":{"row":68,"column":33},"action":"remove","lines":["s"],"id":71},{"start":{"row":68,"column":31},"end":{"row":68,"column":32},"action":"remove","lines":["y"]},{"start":{"row":68,"column":30},"end":{"row":68,"column":31},"action":"remove","lines":["o"]},{"start":{"row":68,"column":29},"end":{"row":68,"column":30},"action":"remove","lines":["B"]},{"start":{"row":68,"column":28},"end":{"row":68,"column":29},"action":"remove","lines":[" "]},{"start":{"row":68,"column":27},"end":{"row":68,"column":28},"action":"remove","lines":["e"]},{"start":{"row":68,"column":26},"end":{"row":68,"column":27},"action":"remove","lines":["h"]},{"start":{"row":68,"column":25},"end":{"row":68,"column":26},"action":"remove","lines":["T"]}],[{"start":{"row":0,"column":0},"end":{"row":75,"column":0},"action":"remove","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client","s3 = boto3.client('s3')","","# S3 bucket and file details","bucket_name = 'myflicksasa'","file_key = 'imdb/combined_processed.csv'","","# Fetch the file from S3","obj = s3.get_object(Bucket=bucket_name, Key=file_key)","data = obj['Body'].read().decode('utf-8')","","# Load the data into a DataFrame","movies_df = pd.read_csv(StringIO(data))","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'IF'","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""],"id":72},{"start":{"row":0,"column":0},"end":{"row":79,"column":0},"action":"insert","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client","s3 = boto3.client('s3')","","# S3 bucket and file details","bucket_name = 'Flicksasa'","file_key = 'imdb/combined_processed.csv'","","# Fetch the file from S3","obj = s3.get_object(Bucket=bucket_name, Key=file_key)","data = obj['Body'].read().decode('utf-8')","","# Load the data into a DataFrame","movies_df = pd.read_csv(StringIO(data))","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Print the first few movie titles to verify","print(\"Available movie titles:\")","print(movies_df['title'].head(20))","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'House of the Dragon'  # Change to a valid movie title","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""]}],[{"start":{"row":10,"column":15},"end":{"row":10,"column":24},"action":"remove","lines":["Flicksasa"],"id":73},{"start":{"row":10,"column":15},"end":{"row":10,"column":26},"action":"insert","lines":["myflicksasa"]}],[{"start":{"row":0,"column":0},"end":{"row":79,"column":0},"action":"remove","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client","s3 = boto3.client('s3')","","# S3 bucket and file details","bucket_name = 'myflicksasa'","file_key = 'imdb/combined_processed.csv'","","# Fetch the file from S3","obj = s3.get_object(Bucket=bucket_name, Key=file_key)","data = obj['Body'].read().decode('utf-8')","","# Load the data into a DataFrame","movies_df = pd.read_csv(StringIO(data))","","# Preprocess the description column","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","print(\"Initializing the TF-IDF Vectorizer...\")","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","# Compute the cosine similarity matrix","print(\"Computing the cosine similarity matrix...\")","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","# Create a reverse map of indices and movie titles","indices = pd.Series(movies_df.index, index=movies_df['title']).drop_duplicates()","","# Print the first few movie titles to verify","print(\"Available movie titles:\")","print(movies_df['title'].head(20))","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    print(f\"Getting recommendations for: {title}\")","    ","    # Check if the movie title exists in the dataset","    if title not in indices:","        print(\"Movie title not found in the dataset.\")","        return []","    ","    # Get the index of the movie that matches the title","    idx = indices[title]","","    # Get the pairwise similarity scores of all movies with that movie","    sim_scores = list(enumerate(cosine_sim[idx]))","","    # Sort the movies based on the similarity scores","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","    # Get the scores of the 10 most similar movies","    sim_scores = sim_scores[1:11]","","    # Get the movie indices","    movie_indices = [i[0] for i in sim_scores]","","    # Return the top 10 most similar movies","    recommendations = movies_df['title'].iloc[movie_indices]","    print(\"Recommendations found:\")","    print(recommendations)","    return recommendations","","# Example: Get recommendations for a specific movie","user_favorite_movie = 'House of the Dragon'  # Change to a valid movie title","recommendations = get_recommendations(user_favorite_movie)","","# Display the recommendations","print(\"\\nTop 10 movie recommendations:\")","for i, movie in enumerate(recommendations, 1):","    print(f\"{i}. {movie}\")",""],"id":74},{"start":{"row":0,"column":0},"end":{"row":91,"column":0},"action":"insert","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client with region (if needed)","s3 = boto3.client('s3', region_name='us-west-2')  # Change 'us-west-2' to the correct region","","# S3 bucket and file details","bucket_name = 'Flicksasa'","file_key = 'imdb/combined_processed.csv'","","# List buckets to verify access","response = s3.list_buckets()","buckets = [bucket['Name'] for bucket in response['Buckets']]","print(\"Available buckets:\", buckets)","","# Fetch the file from S3","try:","    obj = s3.get_object(Bucket=bucket_name, Key=file_key)","    data = obj['Body'].read().decode('utf-8')","","    # Load the data into a DataFrame","    movies_df = pd.read_csv(StringIO(data))","","    # Preprocess the description column","    movies_df['description'] = movies_df['description'].fillna('')","","    # Initialize and fit the TF-IDF vectorizer","    print(\"Initializing the TF-IDF Vectorizer...\")","    tfidf = TfidfVectorizer(stop_words='english')","    tfidf_matrix = tfidf.fit_transform(movies_df['description'])","    print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","    # Compute the cosine similarity matrix","    print(\"Computing the cosine similarity matrix...\")","    cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","    print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","    # Strip prefixes from movie titles","    movies_df['clean_title'] = movies_df['title'].str.replace(r'^\\d+\\.\\s*', '', regex=True)","","    # Create a reverse map of indices and cleaned movie titles","    indices = pd.Series(movies_df.index, index=movies_df['clean_title']).drop_duplicates()","","    # Print the first few cleaned movie titles to verify","    print(\"Available movie titles:\")","    print(movies_df['clean_title'].head(20))","","    # Function to get movie recommendations based on description similarity","    def get_recommendations(title, cosine_sim=cosine_sim):","        print(f\"Getting recommendations for: {title}\")","        ","        # Check if the movie title exists in the dataset","        if title not in indices:","            print(\"Movie title not found in the dataset.\")","            return []","        ","        # Get the index of the movie that matches the title","        idx = indices[title]","","        # Get the pairwise similarity scores of all movies with that movie","        sim_scores = list(enumerate(cosine_sim[idx]))","","        # Sort the movies based on the similarity scores","        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","        # Get the scores of the 10 most similar movies","        sim_scores = sim_scores[1:11]","","        # Get the movie indices","        movie_indices = [i[0] for i in sim_scores]","","        # Return the top 10 most similar movies","        recommendations = movies_df['clean_title'].iloc[movie_indices]","        print(\"Recommendations found:\")","        print(recommendations)","        return recommendations","","    # Example: Get recommendations for a specific movie","    user_favorite_movie = 'House of the Dragon'  # Change to a valid movie title","    recommendations = get_recommendations(user_favorite_movie)","","    # Display the recommendations","    print(\"\\nTop 10 movie recommendations:\")","    for i, movie in enumerate(recommendations, 1):","        print(f\"{i}. {movie}\")","","except s3.exceptions.NoSuchBucket:","    print(f\"Error: The bucket '{bucket_name}' does not exist.\")",""]}],[{"start":{"row":10,"column":15},"end":{"row":10,"column":24},"action":"remove","lines":["Flicksasa"],"id":75},{"start":{"row":10,"column":15},"end":{"row":10,"column":26},"action":"insert","lines":["myflicksasa"]}],[{"start":{"row":81,"column":45},"end":{"row":81,"column":46},"action":"remove","lines":["n"],"id":76},{"start":{"row":81,"column":44},"end":{"row":81,"column":45},"action":"remove","lines":["o"]},{"start":{"row":81,"column":43},"end":{"row":81,"column":44},"action":"remove","lines":["g"]},{"start":{"row":81,"column":42},"end":{"row":81,"column":43},"action":"remove","lines":["a"]},{"start":{"row":81,"column":41},"end":{"row":81,"column":42},"action":"remove","lines":["r"]},{"start":{"row":81,"column":40},"end":{"row":81,"column":41},"action":"remove","lines":["D"]},{"start":{"row":81,"column":39},"end":{"row":81,"column":40},"action":"remove","lines":[" "]},{"start":{"row":81,"column":38},"end":{"row":81,"column":39},"action":"remove","lines":["e"]},{"start":{"row":81,"column":37},"end":{"row":81,"column":38},"action":"remove","lines":["h"]},{"start":{"row":81,"column":36},"end":{"row":81,"column":37},"action":"remove","lines":["t"]},{"start":{"row":81,"column":35},"end":{"row":81,"column":36},"action":"remove","lines":[" "]}],[{"start":{"row":81,"column":34},"end":{"row":81,"column":35},"action":"remove","lines":["f"],"id":77},{"start":{"row":81,"column":33},"end":{"row":81,"column":34},"action":"remove","lines":["o"]},{"start":{"row":81,"column":32},"end":{"row":81,"column":33},"action":"remove","lines":[" "]},{"start":{"row":81,"column":31},"end":{"row":81,"column":32},"action":"remove","lines":["e"]},{"start":{"row":81,"column":30},"end":{"row":81,"column":31},"action":"remove","lines":["s"]},{"start":{"row":81,"column":29},"end":{"row":81,"column":30},"action":"remove","lines":["u"]},{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"remove","lines":["o"]},{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"remove","lines":["H"]}],[{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"insert","lines":["I"],"id":78},{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"insert","lines":["F"]}],[{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"remove","lines":["F"],"id":79},{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"remove","lines":["I"]}],[{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"insert","lines":["S"],"id":80},{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"insert","lines":["c"]},{"start":{"row":81,"column":29},"end":{"row":81,"column":30},"action":"insert","lines":["a"]},{"start":{"row":81,"column":30},"end":{"row":81,"column":31},"action":"insert","lines":["r"]},{"start":{"row":81,"column":31},"end":{"row":81,"column":32},"action":"insert","lines":["y"]}],[{"start":{"row":81,"column":32},"end":{"row":81,"column":33},"action":"insert","lines":[" "],"id":81},{"start":{"row":81,"column":33},"end":{"row":81,"column":34},"action":"insert","lines":["M"]},{"start":{"row":81,"column":34},"end":{"row":81,"column":35},"action":"insert","lines":["o"]},{"start":{"row":81,"column":35},"end":{"row":81,"column":36},"action":"insert","lines":["v"]},{"start":{"row":81,"column":36},"end":{"row":81,"column":37},"action":"insert","lines":["i"]}],[{"start":{"row":81,"column":37},"end":{"row":81,"column":38},"action":"insert","lines":["e"],"id":82}],[{"start":{"row":81,"column":37},"end":{"row":81,"column":38},"action":"remove","lines":["e"],"id":83},{"start":{"row":81,"column":36},"end":{"row":81,"column":37},"action":"remove","lines":["i"]},{"start":{"row":81,"column":35},"end":{"row":81,"column":36},"action":"remove","lines":["v"]},{"start":{"row":81,"column":34},"end":{"row":81,"column":35},"action":"remove","lines":["o"]},{"start":{"row":81,"column":33},"end":{"row":81,"column":34},"action":"remove","lines":["M"]},{"start":{"row":81,"column":32},"end":{"row":81,"column":33},"action":"remove","lines":[" "]},{"start":{"row":81,"column":31},"end":{"row":81,"column":32},"action":"remove","lines":["y"]},{"start":{"row":81,"column":30},"end":{"row":81,"column":31},"action":"remove","lines":["r"]},{"start":{"row":81,"column":29},"end":{"row":81,"column":30},"action":"remove","lines":["a"]},{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"remove","lines":["c"]},{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"remove","lines":["S"]}],[{"start":{"row":81,"column":27},"end":{"row":81,"column":28},"action":"insert","lines":["I"],"id":84},{"start":{"row":81,"column":28},"end":{"row":81,"column":29},"action":"insert","lines":["F"]}],[{"start":{"row":0,"column":0},"end":{"row":91,"column":0},"action":"remove","lines":["import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","# Initialize boto3 client with region (if needed)","s3 = boto3.client('s3', region_name='us-west-2')  # Change 'us-west-2' to the correct region","","# S3 bucket and file details","bucket_name = 'myflicksasa'","file_key = 'imdb/combined_processed.csv'","","# List buckets to verify access","response = s3.list_buckets()","buckets = [bucket['Name'] for bucket in response['Buckets']]","print(\"Available buckets:\", buckets)","","# Fetch the file from S3","try:","    obj = s3.get_object(Bucket=bucket_name, Key=file_key)","    data = obj['Body'].read().decode('utf-8')","","    # Load the data into a DataFrame","    movies_df = pd.read_csv(StringIO(data))","","    # Preprocess the description column","    movies_df['description'] = movies_df['description'].fillna('')","","    # Initialize and fit the TF-IDF vectorizer","    print(\"Initializing the TF-IDF Vectorizer...\")","    tfidf = TfidfVectorizer(stop_words='english')","    tfidf_matrix = tfidf.fit_transform(movies_df['description'])","    print(\"TF-IDF matrix shape:\", tfidf_matrix.shape)","","    # Compute the cosine similarity matrix","    print(\"Computing the cosine similarity matrix...\")","    cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","    print(\"Cosine similarity matrix shape:\", cosine_sim.shape)","","    # Strip prefixes from movie titles","    movies_df['clean_title'] = movies_df['title'].str.replace(r'^\\d+\\.\\s*', '', regex=True)","","    # Create a reverse map of indices and cleaned movie titles","    indices = pd.Series(movies_df.index, index=movies_df['clean_title']).drop_duplicates()","","    # Print the first few cleaned movie titles to verify","    print(\"Available movie titles:\")","    print(movies_df['clean_title'].head(20))","","    # Function to get movie recommendations based on description similarity","    def get_recommendations(title, cosine_sim=cosine_sim):","        print(f\"Getting recommendations for: {title}\")","        ","        # Check if the movie title exists in the dataset","        if title not in indices:","            print(\"Movie title not found in the dataset.\")","            return []","        ","        # Get the index of the movie that matches the title","        idx = indices[title]","","        # Get the pairwise similarity scores of all movies with that movie","        sim_scores = list(enumerate(cosine_sim[idx]))","","        # Sort the movies based on the similarity scores","        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","","        # Get the scores of the 10 most similar movies","        sim_scores = sim_scores[1:11]","","        # Get the movie indices","        movie_indices = [i[0] for i in sim_scores]","","        # Return the top 10 most similar movies","        recommendations = movies_df['clean_title'].iloc[movie_indices]","        print(\"Recommendations found:\")","        print(recommendations)","        return recommendations","","    # Example: Get recommendations for a specific movie","    user_favorite_movie = 'IF'  # Change to a valid movie title","    recommendations = get_recommendations(user_favorite_movie)","","    # Display the recommendations","    print(\"\\nTop 10 movie recommendations:\")","    for i, movie in enumerate(recommendations, 1):","        print(f\"{i}. {movie}\")","","except s3.exceptions.NoSuchBucket:","    print(f\"Error: The bucket '{bucket_name}' does not exist.\")",""],"id":85},{"start":{"row":0,"column":0},"end":{"row":66,"column":0},"action":"insert","lines":["from flask import Flask, request, jsonify","import pandas as pd","import boto3","from io import StringIO","from sklearn.feature_extraction.text import TfidfVectorizer","from sklearn.metrics.pairwise import linear_kernel","","app = Flask(__name__)","","# Initialize boto3 client with region (if needed)","s3 = boto3.client('s3', region_name='us-west-2')  # Change 'us-west-2' to the correct region","","# S3 bucket and file details","bucket_name = 'myflicksasa'","file_key = 'imdb/combined_processed.csv'","","# Fetch the file from S3","def fetch_movie_data():","    obj = s3.get_object(Bucket=bucket_name, Key=file_key)","    data = obj['Body'].read().decode('utf-8')","    return pd.read_csv(StringIO(data))","","# Load and preprocess data","movies_df = fetch_movie_data()","movies_df['description'] = movies_df['description'].fillna('')","","# Initialize and fit the TF-IDF vectorizer","tfidf = TfidfVectorizer(stop_words='english')","tfidf_matrix = tfidf.fit_transform(movies_df['description'])","","# Compute the cosine similarity matrix","cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)","","# Strip prefixes from movie titles","movies_df['clean_title'] = movies_df['title'].str.replace(r'^\\d+\\.\\s*', '', regex=True)","","# Create a reverse map of indices and cleaned movie titles","indices = pd.Series(movies_df.index, index=movies_df['clean_title']).drop_duplicates()","","# Function to get movie recommendations based on description similarity","def get_recommendations(title, cosine_sim=cosine_sim):","    if title not in indices:","        return []","    ","    idx = indices[title]","    sim_scores = list(enumerate(cosine_sim[idx]))","    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)","    sim_scores = sim_scores[1:11]","    movie_indices = [i[0] for i in sim_scores]","    recommendations = movies_df['clean_title'].iloc[movie_indices]","    return recommendations.tolist()","","@app.route('/recommend', methods=['GET'])","def recommend():","    title = request.args.get('title')","    if not title:","        return jsonify({'error': 'Title parameter is required'}), 400","","    recommendations = get_recommendations(title)","    if not recommendations:","        return jsonify({'error': 'Movie title not found'}), 404","","    return jsonify({'recommendations': recommendations})","","if __name__ == '__main__':","    app.run(debug=True)",""]}]]},"ace":{"folds":[],"scrolltop":630.5454155040117,"scrollleft":0,"selection":{"start":{"row":51,"column":51},"end":{"row":51,"column":51},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":44,"state":"start","mode":"ace/mode/python"}},"timestamp":1721977320852,"hash":"c32d27607b839b8ae3010213ff42cfb707323b64"}